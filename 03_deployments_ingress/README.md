# 3. Deployments and ingress

## 3.0 Confirm the environment is set up completely
If you haven't setup the aliases from the previous section, use `sudo microk8s kubectl` instead of `kubectl` and `sudo microk8s` instead of `microk8s`
* Check the nodes are ready: `kubectl get nodes -o wide`
* If a node is not ready, see `kubectl describe node <node name>`
* Check if the machine running the node is stalled
* If the problem is with calico (CNI), or it gives `kubelet stopped posting` error, try setting internal IP of the machines
to their advertised IPs (192.168.50.XX) on **all nodes**:
    1. run `microk8s stop` on the manager node
    1. add `--node-ip=192.168.50.16` to `/var/snap/microk8s/current/args/kubelet`
    1. add `--advertise-address=192.168.50.16` to `/var/snap/microk8s/current/args/kube-apiserver`
    1. restart microk8s: `microk8s start`
* If the virtual machine is not stalled, run `sudo microk8s inspect`. 
    * If a service failed, try restarting it manually using `sudo systemctl start <service name>`. 
    <!-- If this doesn't work, remove the node and add it manually:
        * on the manager node, drain the node first: `kubectl drain <node name>`. You may have to use `--ignore-daemonsets` or `--delete-local-data`
        * then delete the node from the cluster using `kubectl delete node <node name>`
        * run `microk8s add node -l 60`, then connect to the node using `ssh vboxXX` and run the command generated by the `add node` with the `--worker` flag -->
* Check all pods are running well: `kubectl get pods -A`
<!-- * If `calico-node-xxxxx` in `kube-system` is failing with `CrashLoopBackOff`, proceed with the [following](https://seungbae.notion.site/Calico-Node-CrashLoopBackOff-02d772f440704c7d823f216052ad4e46):
    * on the **manager node**, open `/var/snap/microk8s/current/args/cni-network/cni.yaml`
    * search for `IP_AUTODETECTION_METHOD`, change the value from `can-reach=192.168.50.XX` or `first-found` to `interface=wlo.*` 
    * change `timeoutSeconds` for `livenessProbe` and `readinessProbe` to 60 seconds.
    * apply the configuration: `kubectl apply -f /var/snap/microk8s/current/args/cni-network/cni.yaml` -->
* Don't forget to pray to whatever god you believe in, and if you don't believe in any pray to k8s instead, maybe it'll have mercy on you.

## 3.1 Create a namespace for the test deployments
This will create a `helloworld` namespace which will be used further. It can be created via a command or by passing a yaml file.  

Run the following: `ansible-playbook playbooks/setup_namespace.yaml`. You can check the new namespace using `kubectl get namespaces`.

## 3.2 Create test deployments
This will create `hello-world` and `myapp` deployments in the `helloworld` namespace. Each has its own service (named `(...)-svc`) and an ingress forwarding this service (named `(...)-ing`).  

Run the following: `ansible-playbook playbooks/setup_deployments.yaml`. The apps are available at `myapp.k8s.cluster` and `helloworld.k8s.cluster`.

## 3.3 Create dashboard ingress
This will create an ingress for the dashboard, available at `dashboard.k8s.cluster`. The configuration for the dashboard ingress comes from the `dashboard/ingress.yaml` file. 

Run `ansible-playbook playbooks/setup_dashboard.yaml`. If you want to use a self-signed certificate, uncomment first 3 tasks in the playbook, and make sure that the generated secret is used in the ingress config.
The default name of the secret is `dashboard-cert`, available in the `kube-system` namespace.

To get the login token, run `ansible-playbook/generate_dashboard_token.yaml`. This will generate a token available for 720 hours, and save it to `login_token.txt` file. Do not do this in production.